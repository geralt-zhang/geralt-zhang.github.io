---
layout: lecture
title: "disk part"
date: 2025-11-22
ready: true
sync: true
tags: [a]
syncdate: 2025-11-22
---

# 从按下电源到看到桌面：深入理解计算机启动

你有没有想过，当你按下电脑的电源按钮那一刻，电脑是如何从黑屏状态一步步启动起来的？从硬盘中加载操作系统，到最后显示桌面，中间经历了什么？

今天我就来带你揭开这个过程的神秘面纱。

## 第一步：硬盘的"身份证" - 分区表

在讲启动之前，我们先要理解硬盘的结构。

你的硬盘就像一个大柜子。买来的新硬盘是空的，计算机需要知道怎么使用它。所以第一件事就是给硬盘做"规划"——把它分成几个独立的部分，每个部分用来存放不同的东西。这些部分就叫**分区**。

比如，你可能会这样规划一个 1TB 的硬盘：
- 第一部分（512MB）：用来存放启动文件
- 第二部分（100GB）：用来存放 Windows 系统
- 第三部分（200GB）：用来存放 Linux 系统  
- 第四部分（剩余 700GB）：用来存放你的个人文件

但硬盘本身是"无脑"的，它不知道这些分区的存在。那谁来告诉电脑有哪些分区呢？答案是一个特殊的数据结构叫**分区表**。分区表就像硬盘的"地图"，记录了每个分区在硬盘上的位置和大小。

### MBR 时代的局限性

在很长一段时间里，电脑使用的分区表格式叫 **MBR**（主引导记录）。这是一个非常古老的设计，甚至可以追溯到 1980 年代的 IBM PC 时代。

MBR 的工作原理很简单粗暴：硬盘的最开始 512 个字节被划分为三个部分：
- 前 446 字节：启动代码（告诉 CPU 应该执行什么）
- 接下来 64 字节：分区表（记录有哪些分区）
- 最后 2 字节：校验信息

你看出问题了吗？只有 64 字节用来记录分区信息。在 1980 年代，这似乎已经够用了。但随着硬盘容量越来越大，这个设计的局限性逐渐暴露：

- **分区数限制**：MBR 最多只能定义 4 个"主分区"。如果你想要更多分区，必须用一个变通方案叫"扩展分区"，但这很麻烦。
- **容量限制**：MBR 使用 32 位来记录分区大小，最大只能支持 2TB 的硬盘。到了 2010 年代，3TB、4TB 的硬盘已经很常见了。
- **可靠性问题**：所有分区信息都集中在硬盘最开始的 512 字节。如果这个地方出了问题，整个硬盘就无法使用。

### GPT 的新时代

后来，业界推出了新的分区表格式叫 **GPT**（GUID 分区表）。这是一个彻底的升级：

首先，GPT 给每个分区都分配一个全球唯一标识符（GUID），就像给每个人都发一个独一无二的身份证号。然后，它使用更多的空间来记录分区信息，支持理论上无限数量的分区。最重要的是，GPT 的分区信息有**多个备份**。不仅在硬盘开头有一份，在硬盘末尾还有一份完整的备份，确保即使前面的数据损坏了，也能从备份恢复。

GPT 还向后兼容 MBR。它在硬盘最开头放一个叫"保护型 MBR"的东西，这样老的操作系统也能识别这个硬盘（虽然看不到 GPT 分区，但至少不会误操作）。

从 2010 年开始，GPT 成为了新硬盘和新操作系统的标准选择。

## 第二部分：系统如何启动

现在你理解了硬盘的分区布局。但这还只是硬件的"地图"。当你真正按下电源按钮时，计算机到底做什么呢？

想象一下这样的场景：你的电脑就像一个睡着的人。当闹钟响起（电源按钮被按下），这个人需要一个方式来醒过来。但醒过来后，他需要知道今天要干什么。电脑也是一样的——它需要知道从哪里启动操作系统。

### 从古老的 BIOS 时代说起

让我们先回到 1980 年代，看看当时的 IBM PC 是怎么启动的。

CPU 上电时，它不知道该执行什么代码。所以芯片设计者做了一个约定：CPU 在复位后，会自动跳转到一个固定的地址，去执行那里的代码。这段代码保存在主板上的 ROM（只读存储器）里，就是 BIOS。

BIOS 醒过来后做的第一件事是什么？检查一下硬件。它会问自己："内存好吗？硬盘连上了吗？显卡工作吗？"这个过程叫 **POST**（加电自检）。如果硬件有问题，你会听到蜂鸣声。如果一切正常，BIOS 继续下一步。

然后 BIOS 做的事情很有意思——它从硬盘的**最开始**读取 512 个字节，这就是 MBR（主引导记录）。MBR 的前 446 个字节是一段小程序。BIOS 会执行这段程序，这段程序的工作是：找到标记为"可启动"的分区，然后从那个分区读取启动程序，并执行它。最后，这个启动程序会加载操作系统内核。

整个过程是一个接力赛：BIOS（固件）→ MBR（446 字节代码）→ 分区启动程序 → 操作系统。

这个设计虽然聪明，但有个致命的缺陷。你想象一下，只有 446 字节的空间来写启动代码。这是什么概念？一张普通纸上的文字有大概 2000 个字符，446 字节连一小段话都装不下。在这么小的空间里，你能做的事情非常有限。而且，BIOS 只有文本界面，没有任何图形支持，启动起来不仅慢，而且用户体验很差。

### UEFI 的革命

随着硬盘变得越来越大（突破 2TB），MBR 的局限性变得无法忍受。业界需要一个全新的方案。从 2006 年左右开始，一个叫 **UEFI**（统一可扩展固件接口）的新标准出现了。

UEFI 的思想完全不同。它说："我们为什么要受限于 446 字节？为什么不能有一个完整的文件系统来存放启动程序呢？"

所以 UEFI 做了什么？它在硬盘上划出一个特殊的分区，叫 **EFI 系统分区**（ESP）。这个分区使用 FAT32 文件系统（就像老的 U 盘格式），通常大小 512MB 左右。然后 UEFI 从这个分区里读取启动加载器，就像读取普通文件一样简单。

这改变了一切。启动加载器不再受 446 字节的限制，可以做更复杂的事情。而且，UEFI 本身就支持图形界面，支持鼠标操作，甚至支持网络功能。你现在看到的那些漂亮的启动菜单、彩色的制造商 Logo，都是 UEFI 的功劳。

### EFI 系统分区——启动的心脏

让我具体带你看看这个特殊的分区。如果你在 Linux 系统上，可以这样查看：

```bash
$ mount | grep efi
/dev/sda1 on /boot/efi type vfat
```

看，EFI 系统分区挂载在 `/boot/efi`。进去看看里面的结构：

```bash
$ ls -la /boot/efi/EFI/
drwxr-xr-x  ubuntu
drwxr-xr-x  BOOT
```

两个目录。`BOOT` 是标准目录，里面是 EFI 规范规定的标准启动文件。`ubuntu` 是 Ubuntu 系统自己创建的目录，放的是 Ubuntu 专用的启动相关文件。

如果你继续深入看：

```bash
$ ls -la /boot/efi/EFI/ubuntu/
-rw-r--r-- grubx64.efi
-rw-r--r-- shimx64.efi
-rw-r--r-- grub.cfg
```

最重要的是 `grubx64.efi`。这是 GRUB 启动加载器。当 UEFI 固件启动时，它会加载并执行这个文件。这个文件就像一个"中介"，它会读取 `grub.cfg` 配置文件，然后决定加载哪个操作系统。

那 `shimx64.efi` 是什么？这是一个安全启动的"垫片"。现代电脑通常启用了"安全启动"（Secure Boot），这意味着 UEFI 只会执行经过签名的程序。但 GRUB 的签名方式和微软的不兼容。所以 shimx64.efi 充当中介——它是由微软签名的，所以能通过安全启动检查，然后它再去验证并执行 GRUB。这样就解决了兼容性问题。

---

## 系统启动过程的完整旅程

现在让我们追踪一台真实电脑的启动过程。假设你有这样的配置：
- 硬盘：1TB NVMe 固态盘（`/dev/sda`）
- 分区方案：GPT（现代标准）
- 启动方式：UEFI（现代标准）
- 操作系统：Ubuntu 22.04

硬盘的分区布局是这样的：

| 设备 | 大小 | 用途 | 文件系统 |
|------|------|------|---------|
| `/dev/sda1` | 512MB | EFI 系统分区（启动文件） | FAT32 |
| `/dev/sda2` | 2GB | Boot 分区（内核） | ext4 |
| `/dev/sda3` | 50GB | Root 分区（系统） | ext4 |
| `/dev/sda4` | 剩余 | Home 分区（用户文件） | ext4 |

从现在开始，让我们按下电源按钮，追踪整个启动过程。

### Phase 1：固件的苏醒（POST 自检）

**发生时间：** 按下电源按钮后的前 1-2 秒

当你按下电源按钮时，整个主板都通了电。CPU 最先醒过来，但它不知道该做什么。所以芯片设计者在 CPU 内部硬编码了一条指令：上电时自动跳转到地址 `0xFFFFFFF0`。

这个地址指向主板上 BIOS/UEFI 芯片中的代码。想象这就像一个"默认程序"——每台 x86 电脑上电时都会自动运行这段代码。这就是 UEFI 固件，它负责从硬件层面唤醒整个系统。

现在固件醒过来了，但它不能盲目地继续。它需要先检查一下"身体"是否都没问题。这就是所谓的 **POST**（Power-On Self Test）加电自检。固件会逐一检查：

- **CPU 缓存** - 初始化 CPU 的 L1、L2、L3 缓存，这些是 CPU 的"短期记忆"
- **内存** - 检测安装了多少内存，每一条内存条都工作正常吗？
- **芯片组** - 初始化南桥、北桥等芯片
- **PCIe 总线** - 检测有多少个设备挂在 PCIe 总线上（显卡、网卡等）
- **硬盘** - 发送命令给硬盘控制器，让它识别这个硬盘（NVMe 还是 SATA）

如果某个硬件出了问题，固件会发出蜂鸣声或者显示错误代码。如果一切正常，你会看到电脑屏幕亮起来，显示主板制造商的 Logo（比如 ASUS、MSI、华硕等）以及 UEFI 版本信息。

这个过程虽然看起来很快（只需要 1-2 秒），但实际上固件做了很多工作。它需要确保硬件环境稳定，这样后面加载的操作系统才能正常运行。

### Phase 2：寻找启动加载器

**发生时间：** 开机后第 2-3 秒

硬件自检完成了，UEFI 固件现在需要找到操作系统。但操作系统在硬盘上，硬盘那么大，UEFI 不可能一个字节一个字节地去找。它需要一个"导航地图"。这就是分区表的作用。

UEFI 从硬盘的第二个扇区开始读取 GPT 分区表信息。GPT 头告诉 UEFI："硬盘上有多少个分区？每个分区在哪里？"最重要的是，UEFI 开始寻找一个特殊的分区——GUID 为 `C12A7328-F81F-11D2-BA4B-00A0C93EC93B` 的分区。这是 EFI 系统分区（ESP）的标识符。

在我们的例子里，ESP 就是 `/dev/sda1`，大小 512MB，文件系统是 FAT32。UEFI 找到它后，直接挂载这个分区，然后进入文件系统去查找启动加载器。

通常的查找路径是：`\EFI\ubuntu\grubx64.efi`（注意这是 Windows 风格的路径）或者 `/EFI/ubuntu/grubx64.efi`（Unix 风格）。

找到 `grubx64.efi` 后，UEFI 会检查它的签名（如果启用了 Secure Boot）。但这里有个小麻烦——GRUB 的签名方式和微软不兼容。所以实际上，UEFI 先加载 `shimx64.efi`（安全启动垫片），这个文件是被微软签名的。然后 shim 验证 GRUB 的签名，再加载 GRUB。这样就绕过了安全启动的限制。

UEFI 把 `grubx64.efi` 这个文件加载到内存中，然后跳转到它的入口点开始执行。从这一刻起，控制权从 UEFI 固件转移到了 GRUB 启动加载器。

### Phase 3：GRUB 启动菜单的世界

**发生时间：** 开机后第 3-5 秒

现在 GRUB 启动加载器已经开始运行了。GRUB 是什么？简单说，它就是一个"系统选择器"。它的工作是读取配置文件，显示菜单给用户，让用户选择要启动哪个操作系统。

GRUB 做的第一件事是初始化自己的环境，然后读取配置文件。这个配置文件就是 `/boot/grub/grub.cfg`。让我们看看这个文件的一个真实例子：

```bash
### BEGIN /etc/grub.d/10_linux ###
menuentry 'Ubuntu 22.04.3 LTS (5.15.0-84-generic)' --class gnu-linux --class os {
    load_video
    insmod gzio
    insmod part_gpt
    insmod ext2
    set root='hd0,gpt3'
    search --no-floppy --fs-uuid --set=root 7a2c3d4e-f5a6-11eb-8f1b-001a2b3c4d5e
    echo 'Loading Ubuntu 22.04.3 LTS ...'
    linux   /boot/vmlinuz-5.15.0-84-generic root=/dev/sda3 ro quiet splash
    echo 'Loading initial ramdisk ...'
    initrd  /boot/initrd.img-5.15.0-84-generic
}
```

这个配置文件告诉 GRUB：在菜单中显示一个叫"Ubuntu 22.04.3 LTS"的选项。如果用户选了这个选项（或者倒计时结束后自动选中），GRUB 就会：

1. **找到根分区** - `set root='hd0,gpt3'` 告诉 GRUB，根分区是第一块硬盘的第三个 GPT 分区（即 `/dev/sda3`）
2. **验证分区** - `search` 命令用 UUID 来验证找到的分区是否正确（UUID 就像分区的"身份证号"）
3. **加载内核** - `linux /boot/vmlinuz-5.15.0-84-generic` 告诉 GRUB 从这个位置加载 Linux 内核
4. **加载初始磁盘** - `initrd /boot/initrd.img-5.15.0-84-generic` 加载初始 RAM 磁盘（我们待会讲这是什么）

但在这之前，用户会看到启动菜单：

```
┌───────────────────────────────────┐
│ GNU GRUB version 2.06-2ubuntu14   │
│                                   │
│   Ubuntu 22.04.3 LTS (Default)  ← │
│   Ubuntu 22.04.3 LTS (Recovery)  │
│   Windows 11                      │
│                                   │
│ Use ↑↓ keys, press Enter to boot  │
│ Autoboot in 10 seconds...         │
└───────────────────────────────────┘
```

你可以用上下箭头选择，或者等待 10 秒自动启动默认选项。这就是 GRUB 的工作——一个友好的、可视化的启动菜单。

### Phase 4：内核的苏醒

**发生时间：** 开机后第 5-8 秒

用户选择启动 Ubuntu 后，GRUB 开始干真正的"搬砖"工作。

首先，GRUB 从 `/dev/sda3` 分区（根分区）找到内核文件 `/boot/vmlinuz-5.15.0-84-generic`。这个文件大约 3-5MB，里面包含了整个 Linux 内核的代码。但注意名字里有 "vmlinuz"——这实际上是一个 gzip 压缩过的文件。为什么要压缩？因为内核很大，压缩后可以更快地加载。

GRUB 把这个压缩的内核文件加载到内存里，放在物理地址 0x1000000 起的位置。然后 GRUB 做的很有意思——它还要加载另一个文件 `initrd.img-5.15.0-84-generic`（初始 RAM 磁盘），这个文件大约 50-100MB。

等等，为什么要加载两个东西？这里涉及到一个鸡生蛋、蛋生鸡的问题。

内核需要找到根文件系统（硬盘上真正的 Linux 系统）。但要找到硬盘，内核需要有硬盘驱动程序。硬盘驱动程序呢？它们通常也存在于根文件系统上。这就形成了一个循环：要访问根文件系统需要驱动程序，但驱动程序就在根文件系统上。

怎么办？答案是使用 **initramfs**（初始 RAM 文件系统）。这是一个小型的、临时的文件系统，包含了启动时必需的最小驱动程序和工具。GRUB 先把 initramfs 加载到内存里，然后让内核使用这个临时文件系统。等内核完全启动后，initramfs 会把控制权交给真正的根文件系统。

现在，GRUB 已经把内核和 initramfs 都加载到内存里了。最后，GRUB 跳转到内核的入口点地址（通常是虚拟地址 0xffffffff81000000）。从这一刻起，控制权从 GRUB 转移到了 Linux 内核。

内核醒过来的第一件事是什么？解压缩自己——因为整个内核代码被 gzip 压缩了。然后它初始化 CPU 的 MMU（内存管理单元），启用虚拟内存。接下来，内核初始化中断处理器、系统调用表等关键的系统组件。

你会看到启动日志开始输出：

```
[    0.000000] Linux version 5.15.0-84-generic (ubuntu@lgw01-amd64-039)
[    0.000000] KERNEL supported cpus:
[    0.000000]   Intel GenuineIntel
[    0.000000]   AMD AuthenticAMD
[    0.000000] Command line: root=/dev/sda3 ro quiet splash
```

这些日志告诉你：内核已经启动了，正在初始化各个系统模块。`root=/dev/sda3` 这个参数告诉内核，根文件系统在 `/dev/sda3`。`ro` 表示以只读方式挂载（稍后会转为可读写），`quiet` 表示隐藏详细启动信息，`splash` 表示显示启动画面。

### Phase 5：从 initramfs 到真实的根文件系统

**发生时间：** 开机后第 6-8 秒

现在内核已经初始化好了，但它还在 RAM 里运行，根文件系统还没挂载。内核需要找到硬盘上的真实文件系统。

这时 initramfs 里有一个脚本叫 `/init`，它会执行。这个脚本做的第一件事是加载硬盘驱动程序。对于 NVMe 硬盘来说，驱动程序可能叫 `nvme.ko`（.ko 表示内核模块）。脚本加载这个模块后，内核就能识别 `/dev/sda3` 这个硬盘分区了。

接下来，脚本尝试挂载 `/dev/sda3` 为临时的根目录。然后做一个关键操作：**pivot_root**。这是一个内核系统调用，作用是"切换根文件系统"。它会把当前文件系统的根目录从 initramfs 切换到真正的硬盘根分区。从这一刻起，内核开始使用硬盘上的真实文件系统。

initramfs 的使命完成了。但为什么要这么麻烦？为什么不能直接挂载根文件系统？

答案是：如果根文件系统需要特殊的驱动程序（比如 LVM、RAID、加密文件系统等），而这些驱动程序本身又存在于根文件系统上，就会形成循环依赖。initramfs 解决了这个"先有鸡还是先有蛋"的问题。它包含了所有可能需要的驱动程序，让内核能够访问根文件系统。一旦根文件系统挂载成功，initramfs 的任务就完成了。

### Phase 6：systemd 的统治开始

**发生时间：** 开机后第 8-12 秒

现在内核已经完全启动了，硬盘上的真实文件系统已经挂载。内核做的最后一件事是什么？启动 PID 为 1 的进程。

这个特殊的进程就是系统的"第一市民"——在现代 Linux 系统上，这通常是 **systemd**。systemd 是整个系统的初始化系统，负责启动所有其他服务。

systemd 一启动，就会读取一个叫 `/etc/systemd/system/default.target` 的符号链接。这个链接指向真实的启动目标文件。对于桌面系统来说，通常指向 `graphical.target`（图形化启动目标）。对于服务器来说，通常指向 `multi-user.target`（多用户启动目标）。

以图形化启动为例，systemd 会依次启动：

1. **基础服务**
   - `systemd-journald` - 系统日志守护进程，记录所有系统消息
   - `systemd-udevd` - 设备管理器，负责检测硬件设备
   - `dbus` - 系统消息总线，让不同的进程可以相互通信
   - `systemd-resolved` - DNS 解析器

2. **网络服务**
   - `systemd-networkd` 或 `NetworkManager` - 网络连接管理

3. **挂载服务**
   - 这时 systemd 会挂载 `/boot/efi`、`/home` 等分区。注意，根分区 `/` 早就被内核挂载了，现在轮到其他分区。

4. **显示管理器**
   - `gdm3.service`（GNOME 显示管理器）或其他显示管理器

显示管理器启动后，会初始化图形显示。现在电脑屏幕上会出现登录界面。

### Phase 7：用户登录和最终的桌面

**发生时间：** 开机后第 12-15 秒

现在你看到了 GDM（GNOME 显示管理器）的登录界面。这是一个漂亮的图形界面，显示可用的用户列表。

当你点击你的用户名并输入密码时，GDM 会调用 **PAM**（Pluggable Authentication Modules）来验证你的身份。PAM 是 Linux 上的一个灵活的身份验证框架，支持各种认证方式（密码、指纹、生物识别等）。验证成功后，systemd-logind 创建一个新的会话。

这个会话会被分配一个唯一的会话 ID，比如 `session-c1.scope`。systemd-logind 还会创建这个会话的运行时目录，设置环境变量（`$HOME`、`$USER` 等）。

然后，systemd 为这个用户启动一个专属的 systemd 实例（`systemd --user`），这个实例负责管理这个用户的所有进程。这个用户级的 systemd 会启动一些用户级的服务：

- **pulseaudio** - 音频服务，让你能听到声音
- **dbus-daemon** - 用户消息总线
- 其他用户自定义的服务

最后，systemd 启动桌面环境。对于 GNOME 来说，这意味着启动 `gnome-shell`，它是 GNOME 的核心桌面环境程序。gnome-shell 会启动窗口管理器 `mutter`（负责管理窗口的大小、位置、焦点等），然后加载你的桌面壁纸、任务栏、通知中心等。

到这里，你的桌面终于出现了！整个启动过程从按下电源按钮到看到桌面，通常需要 15-20 秒。

这个过程涉及了硬件、固件、启动加载器、内核、初始化系统、显示系统等众多层次。每一个环节都很关键。如果其中任何一个环节出了问题，你可能会看到黑屏、错误信息，或者启动进度条卡住。

---

## 启动耗时分析

上面我们讲了启动的各个阶段。那实际上每个阶段到底要花多长时间呢？让我们看一个真实的例子。

一台配置相当不错的 Ubuntu 22.04 笔记本，从按下电源到看到桌面，整个过程大概是这样的：

```
阶段                    耗时      累计时间      进度
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
固件初始化 (POST)       1.5秒     1.5秒        [████░░░░░░░░░░░░░░]
硬盘检测和分区表读取    0.5秒     2.0秒        [█████░░░░░░░░░░░░░]
UEFI 加载 GRUB          0.3秒     2.3秒        [██████░░░░░░░░░░░░]
GRUB 菜单显示           3.0秒     5.3秒        [██████████░░░░░░░░]
内核加载和初始化        2.0秒     7.3秒        [███████████░░░░░░░]
initramfs 挂载根分区    1.5秒     8.8秒        [████████████░░░░░░]
systemd 启动系统服务    4.0秒    12.8秒        [████████████████░░]
用户登录和桌面启动      2.0秒    14.8秒        [█████████████████░]
─────────────────────────────────────────────
总计                   14.8秒             [████████████████████]
```

从这个表格里，你可以看到启动过程中最耗时的是什么。大概 35% 的时间用在了 systemd 启动各种系统服务上，20% 用在了硬件初始化，15% 用在了 GRUB 菜单。

### 如何查看真实的启动耗时

理论分析是一回事，查看你自己电脑的真实数据又是另一回事。systemd 提供了一些很好用的工具来分析启动耗时。

首先，你可以运行这个命令：

```bash
$ systemd-analyze
Startup finished in 3.245s (firmware) + 4.123s (loader) + 5.678s (kernel) + 
            3.210s (initrd) + 2.987s (userspace) = 19.243s
```

这会显示从按下电源到 systemd 完成的总耗时。它把启动分解为五个阶段：
- **firmware** - UEFI 固件初始化
- **loader** - 启动加载器
- **kernel** - 内核初始化
- **initrd** - initramfs 阶段
- **userspace** - 用户空间（systemd）

如果你想知道具体是哪些服务最耗时，可以运行：

```bash
$ systemd-analyze blame | head -15
          2.341s docker.service
          1.876s NetworkManager.service
          1.234s systemd-journald.service
           765ms snapd.service
           543ms graphical.target
           412ms udisks2.service
           389ms avahi-daemon.service
           ...
```

这会列出耗时最长的 15 个服务。从这个列表，你可以看到 docker 和 NetworkManager 启动很慢。如果你不需要用到这些服务，可以考虑禁用它们。

还有一个更详细的视图，显示服务之间的依赖关系：

```bash
$ systemd-analyze critical-chain
graphical.target @12.892s
└─multi-user.target @12.892s
  └─docker.service @10.551s +2.341s
    └─basic.target @2.123s
      └─network-online.target @1.456s
        └─NetworkManager.service @0.580s +1.876s
```

这个视图显示了"关键路径"——哪些服务是串联启动的（互相等待），因此是启动时间的瓶颈。

### 如何加快启动速度

知道了耗时分布，如果你想加快启动，该怎么办呢？

1. **禁用不必要的服务**
   
   如果你不使用 Docker，可以禁用它：
   ```bash
   sudo systemctl disable docker.service
   ```
   
   或者禁用 snapd（如果你不用 Snap 软件包）：
   ```bash
   sudo systemctl disable snapd.service
   ```

2. **启用并行启动**
   
   systemd 已经尽量并行启动服务，但有些服务可能有不必要的依赖关系。你可以编辑相关的 `.service` 文件来调整。

3. **使用 SSD**
   
   如果你还在用机械硬盘，升级到 SSD 会带来巨大的性能提升。固态盘的随机读取速度快几十倍，这对启动过程影响很大。

4. **减少开机启动项**
   
   有些软件会在开机时自动启动。检查 `~/.config/autostart/` 目录，删除不必要的启动项。

---

## 理解关键概念

在上面的启动过程中，我们提到了很多术语。让我逐一解释，这次不用那种"列举"的方式，而是用故事来讲解。

### 为什么需要 initramfs？

这是一个很多人困惑的地方。为什么不能直接启动根文件系统，反而要先启动一个临时的 initramfs？

原因其实很现实。想象你是一个患者，需要做手术。但医生在进手术室前，需要先穿上手术服。而这件手术服就放在手术室里。没穿手术服，你进不了手术室；但要进手术室去拿手术服，又需要穿手术服。这就形成了一个循环。

Linux 启动也是一样的。内核要访问硬盘上的根文件系统，但要访问硬盘，需要硬盘驱动程序。而驱动程序通常就存储在根文件系统上。所以业界想出了 initramfs 这个办法——包含最基本的驱动程序的临时文件系统，帮助内核"穿上手术服"，能够访问真正的根文件系统。

### 什么是 pivot_root？

`pivot_root` 是一个内核系统调用，名字有点古怪。但它的作用很简单：切换根文件系统。

当 initramfs 中的 `/init` 脚本成功挂载了硬盘上的真实根文件系统后，它会调用 `pivot_root` 来切换。这个调用的效果就像"打开一扇门，走进真实的世界"。从这一刻起，内核使用的 `/` 就指向硬盘上的真实根分区，而不是内存中的 initramfs。

initramfs 的工作完成了，所以通常会被丢弃（清除）。

### GRUB 配置文件那些参数是什么意思？

GRUB 配置文件中有一行很重要：

```bash
linux /boot/vmlinuz-5.15.0-84-generic root=/dev/sda3 ro quiet splash
```

这一行告诉 GRUB 应该如何启动内核。各个参数的意思是：

- `root=/dev/sda3` - 告诉内核，真正的根文件系统在 `/dev/sda3`。内核启动后，会尝试挂载这个分区。

- `ro` - "read-only" 的缩写。它告诉内核，在最开始以只读方式挂载根文件系统。为什么？因为内核需要先进行文件系统检查和修复，如果文件系统是可写的，会发生冲突。等检查完毕，systemd 会把它改为读写模式。

- `quiet` - 隐藏大多数启动信息。这样启动画面看起来更清爽。如果启动出了问题，你可以删除这个参数，看到详细的启动日志。

- `splash` - 显示启动画面（通常是制造商的 Logo 或一个进度条）。

这些参数合在一起，就像给内核下达的一系列命令。

### 为什么硬盘用 `/dev/sda`？

Linux 给硬盘起的设备名称遵循一定的规则：

- `/dev/sda` - 第一块 SATA 硬盘
- `/dev/sdb` - 第二块 SATA 硬盘
- `/dev/nvme0n1` - 第一块 NVMe 固态盘
- `/dev/nvme1n1` - 第二块 NVMe 固态盘

然后每个硬盘又分成若干分区：

- `/dev/sda1` - 第一块硬盘的第一个分区
- `/dev/sda2` - 第一块硬盘的第二个分区
- 等等

### systemd 和旧的 SysV init 有什么区别？

在 systemd 出现之前，Linux 使用的初始化系统叫 SysV init（来自 Unix System V）。这个古老的系统有个致命缺陷：**串联启动**。

什么意思？就是服务必须一个接一个地启动。如果 A 服务启动需要 2 秒，B 服务启动需要 3 秒，总时间就是 5 秒。

systemd 改进了这一点——它支持**并行启动**。如果 A 和 B 没有依赖关系，它们会同时启动，总时间只需要 3 秒。这对现代的多核 CPU 非常有利，所以 systemd 大大加快了启动速度。

另外，systemd 还引入了 **Target** 的概念。Target 有点像"启动目标"或"运行级别"。比如 `graphical.target` 表示"启动到桌面"，`multi-user.target` 表示"启动到命令行"。不同的 Target 会启动不同的一组服务。

---

## 常用的实用命令

虽然现在大多数启动过程是自动化的，但有时你需要了解或调试启动问题。这里是一些有用的命令。

### 查看启动日志

如果启动过程中出了问题，或者你想了解具体发生了什么，可以查看启动日志：

```bash
# 查看当前这次开机的所有日志
sudo journalctl -b

# 查看上次开机的日志
sudo journalctl -b -1

# 查看从上次启动到 10 分钟内发生的事件
sudo journalctl -b --since "10 min ago"

# 只看某个特定服务的日志
sudo journalctl -u ssh.service -b
```

### 诊断启动性能

```bash
# 显示各阶段的耗时
systemd-analyze

# 显示最耗时的 20 个服务
systemd-analyze blame | head -20

# 显示启动依赖链
systemd-analyze critical-chain

# 生成一个 SVG 图表，可以用浏览器打开看启动过程的可视化
systemd-analyze plot > ~/boot-timeline.svg
```

### 修改启动参数

有时你需要修改内核启动参数。比如，如果启用了 `quiet` 参数导致你看不到启动信息，想要看详细的启动过程，可以：

临时修改（只对这一次开机生效）：
```bash
# 重启电脑
# 在 GRUB 菜单中按 'e' 编辑
# 找到以 "linux" 开头的那一行
# 删除 "quiet" 参数
# 按 Ctrl+X 启动
```

永久修改：
```bash
# 编辑 GRUB 配置
sudo nano /etc/default/grub

# 找到这一行：
# GRUB_CMDLINE_LINUX="..."

# 根据需要修改参数，然后保存

# 重新生成 GRUB 配置
sudo grub-mkconfig -o /boot/grub/grub.cfg

# 重启生效
```

### 检查分区和挂载点

```bash
# 显示所有分区及其挂载点
lsblk -o NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT

# 显示所有分区的 UUID（启动时用这个来识别分区）
sudo blkid

# 查看当前的挂载情况
mount | column -t

# 看看 EFI 系统分区的内容
sudo ls -la /boot/efi/EFI/
```

---

## 总结

从按下电源按钮到看到桌面，电脑经历了一个复杂而精妙的过程：

1. **固件醒过来** - UEFI 进行硬件自检
2. **找到启动加载器** - UEFI 从 ESP 加载 GRUB
3. **显示菜单** - GRUB 让你选择要启动的系统
4. **加载内核** - GRUB 从磁盘读取内核和 initramfs
5. **内核初始化** - Linux 内核启动，建立虚拟内存，初始化硬件驱动
6. **切换到真实根分区** - initramfs 帮助内核找到硬盘上的真实文件系统
7. **systemd 启动服务** - 初始化系统负责启动所有系统服务
8. **显示登录界面** - 显示管理器显示登录屏幕
9. **用户登录** - 创建用户会话，启动桌面环境

整个过程涉及硬件、固件、启动加载器、内核、初始化系统等多个层次。每一个环节都很重要。现在，当你看到电脑启动时，你知道幕后发生了多少事情了吧？